// Generated by CoffeeScript 1.7.1

/* ogre.js - MIT Licensed - http://github.com/elucidata/ogre.js */


/*

Dependencies: Underscore/Lo-Dash

All cursors are virtual, data operations happen on the root source object.

Meaning, you can create cursors for unpopulated paths and set onChange 
handlers for them, then when/if data is ever set for that path you'll get 
the callback.

Notes/Ideas:

- Maybe the onChange callback Event should have a stopPropagation() method
  that would... What? Stop application of the object to the graph? Or maybe
  there would also be a preventDefault() method that would do that and 
  stopPropagation() would just stop calling any further callbacks.
- Add a capture phase to the event triggers...
  - Any changes to e.value would be used in the merge/replace phase of
    the process (and not trigger any further events).


myHandler= (e)->
  e.path #=> the key path of the change
  e.value #=> the new merged value
  e.oldValue #=> the previous value
  e.preventDefault()? #=> prevents further event handler calls?
  e.stopPropagation()? #=> prevents events from bubbling up the graph?
  e.phase #=> 'capture' or 'bubble'

data.onChange myHandler, true # last bool is capture flag
data.onChange myHandler, false
 */

(function() {
  var DEBUG, SETTABLE_VALUES, changeEvent, getKeyParts, getKeyPath, isPlainObject, ogre, setKeyPath, startsWith, type, warnOnce,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  if ((typeof require !== "undefined" && require !== null) && (this._ == null)) {
    global._= require('underscore');
  }

  DEBUG = false;

  SETTABLE_VALUES = 'object array null undefined'.split(' ');

  ogre = function(source, lockEditsToRoot) {
    var cursor, _callbacks, _changeGraph, _fullpath, _lastChangePath, _triggerCallbacks;
    if (lockEditsToRoot == null) {
      lockEditsToRoot = false;
    }
    _callbacks = [];
    _lastChangePath = null;
    _fullpath = function(root, key) {
      return _.compact([root, key]).join('.');
    };
    _triggerCallbacks = function(e) {
      var cb, _i, _len;
      for (_i = 0, _len = _callbacks.length; _i < _len; _i++) {
        cb = _callbacks[_i];
        if (startsWith(e.path, cb != null ? cb.basepath : void 0)) {
          cb.exec(e);
        }
      }
      return e;
    };
    _changeGraph = function(fullpath, data, replace, silent) {
      var e;
      if (e = setKeyPath(source, fullpath, data, replace)) {
        if (silent) {
          return;
        }
        _lastChangePath = e.path;
        _triggerCallbacks(e);
        _lastChangePath = null;
        return warnOnce.clear();
      }
    };
    cursor = function(rootpath, readonly) {
      if (readonly == null) {
        readonly = false;
      }
      return {
        path: rootpath,
        get: function(path, opts) {
          var data, kind;
          if (arguments.length === 1 && type(path) === 'object') {
            opts = path;
            path = '';
          }
          data = getKeyPath(source, _fullpath(rootpath, path));
          kind = type(data);
          if ((kind === 'undefined' || kind === 'null') && ((opts != null ? opts.or : void 0) != null)) {
            return opts.or;
          } else if ((opts != null ? opts.clone : void 0) === false) {
            return data;
          } else {
            return _.clone(data);
          }
        },
        set: function(path, data, replace, silent) {
          var fullpath, kind;
          if (replace == null) {
            replace = false;
          }
          if (silent == null) {
            silent = false;
          }
          if (readonly) {
            console.warn("You're trying to set data on a readonly cursor!");
            return this;
          }
          if ((kind = type(path)) !== 'string') {
            if (__indexOf.call(SETTABLE_VALUES, kind) >= 0) {
              silent = replace;
              replace = data;
              data = path;
              path = '';
            } else {
              console.warn("The first parameter to .set() is an invalid type:", kind);
              return this;
            }
          }
          fullpath = _fullpath(rootpath, path);
          if (_lastChangePath != null) {
            if (startsWith(path, _lastChangePath)) {
              warnOnce("You're making changes in the same path (" + path + ") within an onChange handler. This can lead to infinite loops, be careful.");
            }
          }
          _changeGraph(fullpath, data, replace, silent);
          return this;
        },

        /*
         *   Params: 
         *     .map string, callback
         *     .map callback
         *   Callback Format:
         *     callback(value, idx|key, array|object)
         */
        map: function(path, fn) {
          var idx, key, result, value, _i, _len, _results, _results1;
          fn = arguments[arguments.length - 1];
          result = arguments.length > 1 ? this.get(arguments[0]) : this.get();
          fn || (fn = function(x) {
            return x;
          });
          switch (type(result)) {
            case 'array':
              _results = [];
              for (idx = _i = 0, _len = result.length; _i < _len; idx = ++_i) {
                value = result[idx];
                _results.push(fn(value, idx, result));
              }
              return _results;
              break;
            case 'object':
              _results1 = [];
              for (key in result) {
                value = result[key];
                _results1.push(fn(value, key, result));
              }
              return _results1;
              break;
            case 'null':
            case 'undefined':
              return [];
            default:
              return [fn(result)];
          }
        },
        hasChanged: function(path) {
          var fullpath;
          if (path == null) {
            path = '';
          }
          if (_lastChangePath == null) {
            return false;
          }
          fullpath = _fullpath(rootpath, path);
          return startsWith(_lastChangePath, fullpath);
        },
        exists: function(path) {
          var unlikelyValue;
          if (path == null) {
            path = '';
          }
          unlikelyValue = '*^%^*(*&!';
          return this.get(path, {
            or: unlikelyValue
          }) !== unlikelyValue;
        },
        isEmpty: function(path) {
          var kind;
          if (path == null) {
            path = '';
          }
          kind = type(this.get(path));
          return kind === 'null' || kind === 'undefined';
        },
        isNotEmpty: function(path) {
          if (path == null) {
            path = '';
          }
          return !this.isEmpty(path);
        },
        isNull: function(path) {
          if (path == null) {
            path = '';
          }
          return type(this.get(path)) === 'null';
        },
        isMissing: function(path) {
          if (path == null) {
            path = '';
          }
          return type(this.get(path)) === 'undefined';
        },
        cursor: function(path, readonly) {
          var fullpath;
          fullpath = _fullpath(rootpath, path);
          if (lockEditsToRoot) {
            return cursor(fullpath, true);
          } else {
            return cursor(fullpath, readonly);
          }
        },
        listenerCount: function(reportAll) {
          var cb;
          if (reportAll == null) {
            reportAll = false;
          }
          if (reportAll === true && rootpath === '') {
            return _callbacks.length;
          } else {
            return ((function() {
              var _i, _len, _results;
              _results = [];
              for (_i = 0, _len = _callbacks.length; _i < _len; _i++) {
                cb = _callbacks[_i];
                if (cb.cursor === this) {
                  _results.push(cb);
                }
              }
              return _results;
            }).call(this)).length;
          }
        },
        _listenerSummary: function() {
          var content, data, info, key, paths, total, _i, _j, _len, _len1, _name, _ref, _ref1;
          paths = {};
          total = 0;
          for (_i = 0, _len = _callbacks.length; _i < _len; _i++) {
            info = _callbacks[_i];
            total += 1;
            data = paths[_name = info.basepath] || (paths[_name] = {
              listeners: 0,
              cursors: []
            });
            data.listeners += 1;
            if (_ref = info.cursor, __indexOf.call(data.cursors, _ref) < 0) {
              data.cursors.push(info.cursor);
            }
          }
          content = ["" + total + " listeners in ogre."];
          _ref1 = _.keys(paths).sort();
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            key = _ref1[_j];
            info = paths[key];
            content.push("  " + (key || '<root>') + ":");
            content.push("    - listeners " + info.listeners);
            content.push("    -   cursors " + info.cursors.length);
          }
          return content.join("\n");
        },
        onChange: function(callback, path) {

          /** path is optional, defaults to path of cursor */
          var fullpath;
          if (DEBUG) {
            console.log(':cursor: start listening for changes', rootpath || '<root>');
          }
          fullpath = path != null ? _fullpath(rootpath, path) : rootpath;
          _callbacks.push({
            exec: callback,
            basepath: fullpath,
            cursor: this
          });
          return this;
        },
        stopListening: function(clearAll) {
          var callback, i, idx, _i, _j, _len, _len1, _ref;
          if (clearAll == null) {
            clearAll = false;
          }
          if (clearAll === true && rootpath === '') {
            if (DEBUG) {
              console.log(':cursor: clearing all callbacks', rootpath || '<root>');
            }
            _callbacks.length = 0;
          } else {
            idx = [];
            for (i = _i = 0, _len = _callbacks.length; _i < _len; i = ++_i) {
              callback = _callbacks[i];
              if (callback.cursor === this) {
                idx.push(i);
              }
            }
            if (DEBUG && idx.length > 0) {
              console.log(':cursor: stop listening for changes', rootpath || '<root>');
            }
            _ref = idx.sort().reverse();
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              i = _ref[_j];
              _callbacks.splice(i, 1);
            }
          }
          return this;
        },
        stopListeningAt: function(path) {
          var callback, i, idx, _i, _j, _len, _len1, _ref;
          if ((path != null) && !_.isEmpty(path)) {
            _fullpath(rootpath, path);
            idx = [];
            for (i = _i = 0, _len = _callbacks.length; _i < _len; i = ++_i) {
              callback = _callbacks[i];
              if (startsWith(path, callback.basepath)) {
                idx.push(i);
              }
            }
            if (DEBUG && idx.length > 0) {
              console.log(':cursor: stop listening for changes at', fullpath);
            }
            _ref = idx.sort().reverse();
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              i = _ref[_j];
              _callbacks.splice(i, 1);
            }
          } else {
            if (DEBUG) {
              console.warn("You must specify a path to stop listening to.");
            }
          }
          return this;
        },
        dispose: function() {
          return this.stopListening(rootpath === '');
        }
      };
    };
    return cursor('', lockEditsToRoot);
  };

  changeEvent = function(path, value, oldValue) {
    return {
      path: path,
      value: value,
      oldValue: oldValue
    };
  };

  warnOnce = (function() {
    var api, count;
    count = 0;
    api = function(msg) {
      if (count === 0) {
        console.warn(msg);
      }
      return count += 1;
    };
    api.clear = function() {
      return count = 0;
    };
    return api;
  })();

  getKeyParts = function(keypath) {
    return _.compact(keypath.split('.'));
  };

  getKeyPath = function(source, keypath, create) {
    var key, obj, parts;
    if (keypath == null) {
      keypath = '';
    }
    if (create == null) {
      create = false;
    }
    parts = getKeyParts(keypath);
    obj = source;
    while ((obj != null) && parts.length) {
      key = parts.shift();
      if (!obj[key]) {
        if (create === true) {
          obj[key] = {};
        }
      }
      obj = obj[key];
    }
    return obj;
  };

  setKeyPath = function(source, keypath, data, replace) {
    var container, current, key, merged, parts;
    if (keypath == null) {
      keypath = '';
    }
    parts = getKeyParts(keypath);
    key = parts.pop();
    container = parts.length ? getKeyPath(source, parts.join('.'), true) : source;
    if (_.isEqual(container[key], data)) {
      return false;
    }
    current = container[key];
    if (replace === true || !isPlainObject(data)) {
      container[key] = data;
    } else {
      merged = _.extend(_.clone(current || {}), data);
      if (_.isEqual(current, merged)) {
        return false;
      }
      container[key] = merged;
      data = merged;
    }
    return changeEvent(keypath, data, current);
  };

  type = (function() {
    var classToType, elemParser, name, _i, _len, _ref, _toString;
    _toString = Object.prototype.toString;
    elemParser = /\[object HTML(.*)\]/;
    classToType = {};
    _ref = "Array Boolean Date Function NodeList Null Number RegExp String Undefined ".split(" ");
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      name = _ref[_i];
      classToType["[object " + name + "]"] = name.toLowerCase();
    }
    return function(obj) {
      var found, strType;
      strType = _toString.call(obj);
      if (found = classToType[strType]) {
        return found;
      } else if (found = strType.match(elemParser)) {
        return found[1].toLowerCase();
      } else {
        return "object";
      }
    };
  })();

  isPlainObject = function(obj) {
    return type(obj) === 'object';
  };

  startsWith = function(str, starts) {
    if (starts === '') {
      return true;
    }
    if (str === null || starts === null) {
      return false;
    }
    str = String(str);
    starts = String(starts);
    return str.length >= starts.length && str.slice(0, starts.length) === starts;
  };

  if (typeof module !== "undefined" && module !== null) {
    module.exports = ogre;
  } else {
    this.ogre = ogre;
  }

}).call(this);
